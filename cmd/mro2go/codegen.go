//
// Copyright (c) 2017 10X Genomics, Inc. All rights reserved.
//

package main

import (
	"bytes"
	"go/format"
	"go/parser"
	"go/token"
	"io"

	"github.com/martian-lang/martian/martian/syntax"
)

func getParamStructs(ast *syntax.Ast, param syntax.StructMemberLike,
	structs []*syntax.StructType,
	structSet map[string]struct{}) []*syntax.StructType {
	t := ast.TypeTable.Get(syntax.TypeId{Tname: param.GetTname().Tname})
	if s, ok := t.(*syntax.StructType); ok {
		if _, ok := structSet[s.Id]; !ok {
			structSet[s.Id] = struct{}{}
			// Recursively get struct types
			for _, m := range s.Members {
				structs = getParamStructs(ast, m, structs, structSet)
			}
			structs = append(structs, s)
		}
	}
	return structs
}

func getStructs(ast *syntax.Ast, callable syntax.Callable,
	onlyIns bool,
	structs []*syntax.StructType,
	structSet map[string]struct{}) []*syntax.StructType {
	if ins := callable.GetInParams(); ins != nil {
		for _, arg := range ins.List {
			structs = getParamStructs(ast, arg, structs, structSet)
		}
	}
	if !onlyIns {
		if outs := callable.GetOutParams(); outs != nil {
			for _, arg := range outs.List {
				structs = getParamStructs(ast, arg, structs, structSet)
			}
		}
	}
	return structs
}

func anySplit(callables []syntax.Callable) (bool, bool) {
	for i, c := range callables {
		if stage, ok := c.(*syntax.Stage); ok && stage.Split {
			for _, c := range callables[i:] {
				if stage, ok := c.(*syntax.Stage); ok &&
					len(stage.OutParams.List) > 0 &&
					len(stage.ChunkOuts.List) > 0 {
					return true, true
				}
			}
			return true, false
		}
	}
	return false, false
}

func anyStructMap(ss []*syntax.StructType) bool {
	for _, s := range ss {
		for _, m := range s.Members {
			if m.Tname.Tname == syntax.KindMap {
				return true
			}
		}
	}
	return false
}

func anyCallableMap(cs []syntax.Callable, onlyIns bool) bool {
	for _, c := range cs {
		for _, p := range c.GetInParams().List {
			if p.GetTname().Tname == syntax.KindMap {
				return true
			}
		}
		if !onlyIns {
			for _, p := range c.GetOutParams().List {
				if p.GetTname().Tname == syntax.KindMap {
					return true
				}
			}
		}
	}
	return false
}

func needJsonImport(ss []*syntax.StructType, cs []syntax.Callable, onlyIns bool) bool {
	return anyStructMap(ss) || anyCallableMap(cs, onlyIns)
}

func makeCallableGoRaw(ast *syntax.Ast, pkg, mroName string, stageNames []string,
	pipeline, onlyIns bool, seenStructs map[string]struct{}) string {
	var buffer bytes.Buffer
	buffer.WriteString("// Code generated by mro2go ")
	buffer.WriteString(mroName)
	buffer.WriteString("; DO NOT EDIT.\n\n")

	callables := getCallables(ast, mroName, stageNames, pipeline)

	var structs []*syntax.StructType
	if pkg != "" {
		buffer.WriteString("package ")
		buffer.WriteString(pkg)
		buffer.WriteRune('\n')

		if seenStructs != nil {
			for _, c := range callables {
				structs = getStructs(ast, c, onlyIns, structs, seenStructs)
			}
		}
		if split, chunkOuts := anySplit(callables); split {
			buffer.WriteString(`
import (
`)
			if chunkOuts {
				buffer.WriteString("\t\"bytes\"\n")
				buffer.WriteString("\t\"encoding/json\"\n")
			} else if needJsonImport(structs, callables, onlyIns) {
				buffer.WriteString("\t\"encoding/json\"\n")
			}
			buffer.WriteString(`
	"github.com/martian-lang/martian/martian/core"
)

`)
		} else if needJsonImport(structs, callables, onlyIns) {
			buffer.WriteString(`
import (
	"encoding/json"
)
`)
		}
	} else if seenStructs != nil {
		for _, c := range callables {
			structs = getStructs(ast, c, onlyIns, structs, seenStructs)
		}
	}
	for _, s := range structs {
		writeStruct(&buffer, &ast.TypeTable, s)
	}
	for _, c := range callables {
		writeStageStructs(&buffer, &ast.TypeTable, c, onlyIns)
	}
	return buffer.String()
}

// Use gofmt to ensure proper formatting.
func gofmt(dest io.Writer, goSrc, outName string) error {
	fset := token.NewFileSet()
	if f, err := parser.ParseFile(fset, outName, goSrc,
		parser.ParseComments|parser.AllErrors); err != nil {
		_, _ = dest.Write([]byte(goSrc))
		return err
	} else {
		return format.Node(dest, fset, f)
	}
}
